// Append "Proto" if a message collides with a class.
// Do use different name if the responsibility is slightly different
// between a message vs. a class, but don't be too clever to
// avoid collision.
package pentatope;

// A description of rendering a movie with static scene.
// This assumes fixed frame-rate, 2d RGB image stream.
// (currently no stereoscopy or volumetric data)
//
// Renderer need not assume temporal coherency because
// exploiting it is PITA, and optimizing UI and distributed computation
// is much better in practice, especially considering pentatope
// is not coupled with any physics simulator.
message RenderMovieTask {
    // Framerate of the movie. Typically 30 or 60.
    optional float framerate = 1;

    // Size of the movie.
    required uint32 width = 2;
    required uint32 height = 3;

    // All frames. sizes must match the width and height,
    // but other parameters (such as FoV) can vary frame-to-frame.
    repeated CameraConfig frames = 4;

    // The static scene shared by all frames.
    required RenderScene scene = 5;

    optional uint32 sample_per_pixel = 6;
}

// A description of rendering a single frame.
// Contains scene description, camera, output image, etc.
// It's not expected to distribute one RenderTask to
// multiple nodes.
message RenderTask {
    optional string deprecated_scene_name = 1;

    // Average number of samples / px.
    // Note that actual # of samples can vary depending
    // on sampling scheme.
    optional uint32 sample_per_pixel = 2;

    // A camera (and output image) to use for this render.
    optional CameraConfig camera = 3;

    // Output file path. Should be full path.
    optional string output_path = 4;

    // All objects and lights, including materials.
    optional RenderScene scene = 5;
}

// A camera type, pose, blur, tonemap, output image format, etc.
// Although CameraConfig specified output format,
// it's treated as opaque blob; IO should be specified by RenderTask.
message CameraConfig {
    // "perspective2": 2-d sliced perspective point camera.
    optional string camera_type = 1;

    // transform to determine camera pose in the world coordinate.
    optional RigidTransform local_to_world = 5;

    // what's normally called width.
    // must be > 0.
    optional uint32 size_x = 2;

    // what's normally called height.
    // must be > 0.
    optional uint32 size_y = 3;

    // field of view in degree
    // only applicable to perspective camera_type
    optional float fov_x = 6;
    optional float fov_y = 7;
}

// 4-d rigid transform (= SE(4))
// transform(x) = rotation * x + translation
message RigidTransform {
    // row-major 4x4 rotation matrix.
    // must have 16 elements, and the matrix
    // is a proper rotation matrix (det==1).
    // 0 1 2 3
    // ...
    // ...  15
    repeated float rotation = 1 [packed=true];

    // 4-element translation vector.
    repeated float translation = 2 [packed=true];
}

message SpectrumProto {
    // Color values in RGB space.
    // not well-defined.
    optional float r = 1;
    optional float g = 2;
    optional float b = 3;
}

// A point in 4-d space.
message Point {
    required float x = 1;
    required float y = 2;
    required float z = 3;
    required float w = 4;
}

// A unit length vector in 4-d space.
// It can be a normal, a basis, or any other thing.
message Direction {
    required float x = 1;
    required float y = 2;
    required float z = 3;
    required float w = 4;
}

// Scene contains objects and lights.
// Objects can be emissive, but they are not as fast as lights.
message RenderScene {
    repeated SceneObject objects = 1;
    repeated SceneLight lights = 2;

    // Uniform, background radiance. Assumed 0 if omitted.
    optional SpectrumProto background_radiance = 3;
}

message SceneObject {
    optional ObjectGeometry geometry = 1;
    optional ObjectMaterial material = 2;
}

// ObjectGeometry uses extensions to emulate polymorphism.
message ObjectGeometry {
    enum GeometryType {
        OBB = 1;
        TETRAHEDRON = 2;
        SPHERE = 3;
        DISC = 4;
    }
    extensions 100 to max;

    required GeometryType type = 1;
}

message OBBGeometry {
    extend ObjectGeometry {
        optional OBBGeometry geom = 100;
    }
    // Placement of AABB in the world coodinates.
    optional RigidTransform local_to_world = 1;

    // 4-element for size of each axis in local coodinates.
    repeated float size = 3 [packed=true];
}

message TetrahedronGeometry {
    extend ObjectGeometry {
        optional TetrahedronGeometry geom = 101;
    }
    required Point vertex0 = 1;
    required Point vertex1 = 2;
    required Point vertex2 = 3;
    required Point vertex3 = 4;
}

message SphereGeometry {
    extend ObjectGeometry {
        optional SphereGeometry geom = 102;
    }
    required Point center = 1;
    required float radius = 2;
}

message DiscGeometry {
    extend ObjectGeometry {
        optional DiscGeometry geom = 103;
    }
    required Point center = 1;
    required Direction normal = 2;
    required float radius = 3;
}


message ObjectMaterial {
    // Model after (pseudo) real-life objects, because we don't have
    // established BRDF models for 4-d space.
    enum MaterialType {
        UNIFORM_LAMBERT = 1;
        GLASS = 2;
    }
    extensions 100 to max;

    required MaterialType type = 1;
}

message UniformLambertMaterialProto {
    extend ObjectMaterial {
        optional UniformLambertMaterialProto material = 100;
    }

    // Reflectance in [0, 1].
    optional SpectrumProto reflectance = 1;
}

message GlassMaterialProto {
    extend ObjectMaterial {
        optional GlassMaterialProto material = 101;
    }

    // Refractive index of the inside.
    // index > 1 means more solid than air.
    // This should be considered as absolute index,
    // but the tracer currently do not support nested material
    // so it doesn't matter.
    optional float refractive_index = 1;
}


message SceneLight {
    enum LightType {
        POINT = 1;
    }
    extensions 100 to max;

    required LightType type = 1;
}

message PointLightProto {
    extend SceneLight {
        optional PointLightProto light = 100;
    }
    // Location of the point light.
    repeated float translation = 1 [packed=true];

    // Total power of the point light.
    optional SpectrumProto power = 2;
}
